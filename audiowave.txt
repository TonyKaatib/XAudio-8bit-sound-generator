void AudioEngine::GenerateWaveform(WaveformType type, float attackTime, float sustainTime, float releaseTime, float frequency, float frequencySlide, float deltaSlide, float volume, float repeatSpeed) {
	attackSamples = (int)(attackTime * sampleRate);
	sustainSamples = (int)(sustainTime * sampleRate);
	releaseSamples = (int)(releaseTime * sampleRate);

	// Agora repeatSpeed NÃO afeta o envelope, apenas o frequencySlide e deltaSlide
	totalSamples = attackSamples + sustainSamples + releaseSamples;

	if (waveData) {
		delete[] waveData;
	}
	waveData = new short[totalSamples];

	float localPhase = 0.0f;
	float localEnvelope = 1.0f;
	float localFrequency = frequency;

	for (int i = 0; i < totalSamples; i++) {
		// Envelope padrão (sem reinício por repeatSpeed)
		if (i < attackSamples) {
			localEnvelope = (float)i / (attackSamples > 0 ? attackSamples : 1);
		}
		else if (i >= attackSamples + sustainSamples) {
			int relPos = i - attackSamples - sustainSamples;
			localEnvelope = 1.0f - (float)relPos / (releaseSamples > 0 ? releaseSamples : 1);
			if (localEnvelope < 0.0f) localEnvelope = 0.0f;
		}
		else {
			localEnvelope = 1.0f;
		}

		// Cálculo de t para frequencySlide/deltaSlide, afetado por repeatSpeed
		float t;
		if (repeatSpeed > 0.0f) {
			int repeatSamples = (int)(sampleRate / repeatSpeed);
			int posInRepeat = i % repeatSamples;
			t = (float)posInRepeat / repeatSamples;
		} else {
			t = (float)i / totalSamples;
		}

		localFrequency = frequency + (frequencySlide * t) + (deltaSlide * t * t);
		localFrequency = max(localFrequency, 1.0f);

		localPhase += (2.0f * 3.14159265f * localFrequency) / sampleRate;

		switch (type)
		{
		case SINE:
			waveData[i] = (short)(amplitude * localEnvelope * sinf(localPhase) * volume);
			break;
		case SQUARE:
			waveData[i] = (short)(amplitude * localEnvelope * (sinf(localPhase) >= 0 ? 1.0f : -1.0f) * volume);
			break;
		case TRIANGLE:
			waveData[i] = (short)(amplitude * localEnvelope * (2.0f * fabs(2.0f * (localPhase / (2.0f * 3.14159265f) - floor(localPhase / (2.0f * 3.14159265f) + 0.5f))) - 1.0f) * volume);
			break;
		case SAWTOOTH:
			waveData[i] = (short)(amplitude * localEnvelope * (2.0f * (localPhase / (2.0f * 3.14159265f) - floor(localPhase / (2.0f * 3.14159265f) + 0.5f))) * volume);
			break;
		default:
			break;
		}
	}

	wfx.Format.wFormatTag = WAVE_FORMAT_PCM;
	wfx.Format.nChannels = 1;
	wfx.Format.nSamplesPerSec = sampleRate;
	wfx.Format.wBitsPerSample = 16;
	wfx.Format.nBlockAlign = (wfx.Format.nChannels * wfx.Format.wBitsPerSample) / 8;
	wfx.Format.nAvgBytesPerSec = wfx.Format.nSamplesPerSec * wfx.Format.nBlockAlign;
	wfx.Format.cbSize = 0;
	buffer.AudioBytes = totalSamples * sizeof(short);
	buffer.pAudioData = (BYTE*)waveData;
	buffer.Flags = XAUDIO2_END_OF_STREAM;
	if (XAudioSource) {
		XAudioSource->Stop(0);
		XAudioSource->FlushSourceBuffers();
		XAudioSource->DestroyVoice();
	}
	HRESULT hr = XAudio->CreateSourceVoice(&XAudioSource, (WAVEFORMATEX*)&wfx);
	if (FAILED(hr)) {
		MessageBoxA(NULL, "Failed to create source voice!", "Time to debug", MB_OK);
		return;
	}
	hr = XAudioSource->SubmitSourceBuffer(&buffer);
	if (FAILED(hr)) {
		MessageBoxA(NULL, "Failed to submit source buffer!", "Time to debug", MB_OK);
		return;
	}
}