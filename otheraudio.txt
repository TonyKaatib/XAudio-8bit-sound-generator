void AudioEngine::GenerateSineWave(float attackTime, float sustainTime, float releaseTime, float frequency, float frequencySlide, float deltaSlide, float volume) {
	const int sampleRate = 44100;
	const int amplitude = 32767;
	int attackSamples = (int)(attackTime * sampleRate);
	int sustainSamples = (int)(sustainTime * sampleRate);
	int releaseSamples = (int)(releaseTime * sampleRate);
	int totalSamples = attackSamples + sustainSamples + releaseSamples;
	short* waveData = new short[totalSamples];
	float phase = 0.0f;
	for (int i = 0; i < totalSamples; i++) {
		float envelope = 1.0f;
		if (i < attackSamples) {
			envelope = (float)i / attackSamples;
		}
		else if (i >= attackSamples + sustainSamples) {
			envelope = 1.0f - (float)(i - attackSamples - sustainSamples) / releaseSamples;
		}
		float currentFrequency = frequency + (frequencySlide * ((float)i / totalSamples)) + (deltaSlide * ((float)i / totalSamples) * ((float)i / totalSamples));
		currentFrequency = max(currentFrequency, 1.0f); // Prevent negative or zero frequency
		phase += (2.0f * 3.14159265f * currentFrequency) / sampleRate;
		waveData[i] = (short)(amplitude * envelope * sinf(phase) * volume);
	}
	wfx.Format.wFormatTag = WAVE_FORMAT_PCM;
	wfx.Format.nChannels = 1;
	wfx.Format.nSamplesPerSec = sampleRate;
	wfx.Format.wBitsPerSample = 16;
	wfx.Format.nBlockAlign = (wfx.Format.nChannels * wfx.Format.wBitsPerSample) / 8;
	wfx.Format.nAvgBytesPerSec = wfx.Format.nSamplesPerSec * wfx.Format.nBlockAlign;
	wfx.Format.cbSize = 0;
	buffer.AudioBytes = totalSamples * sizeof(short);
	buffer.pAudioData = (BYTE*)waveData;
	buffer.Flags = XAUDIO2_END_OF_STREAM;
	if (XAudioSource) {
		XAudioSource->Stop(0);
		XAudioSource->FlushSourceBuffers();
		XAudioSource->DestroyVoice();
	}
	HRESULT hr = XAudio->CreateSourceVoice(&XAudioSource, (WAVEFORMATEX*)&wfx);
	if (FAILED(hr)) {
		MessageBoxA(NULL, "Failed to create source voice!", "Time to debug", MB_OK);
		return;
	}
	hr = XAudioSource->SubmitSourceBuffer(&buffer);
	if (FAILED(hr)) {
		MessageBoxA(NULL, "Failed to submit source buffer!", "Time to debug", MB_OK);
		return;
	}
}

void AudioEngine::GenerateSquareWave(float attackTime, float sustainTime, float releaseTime, float frequency, float frequencySlide, float deltaSlide, float volume) {
	const int sampleRate = 44100;
	const int amplitude = 32767;
	int attackSamples = (int)(attackTime * sampleRate);
	int sustainSamples = (int)(sustainTime * sampleRate);
	int releaseSamples = (int)(releaseTime * sampleRate);
	int totalSamples = attackSamples + sustainSamples + releaseSamples;
	short* waveData = new short[totalSamples];
	float phase = 0.0f;
	for (int i = 0; i < totalSamples; i++) {
		float envelope = 1.0f;
		if (i < attackSamples) {
			envelope = (float)i / attackSamples;
		}
		else if (i >= attackSamples + sustainSamples) {
			envelope = 1.0f - (float)(i - attackSamples - sustainSamples) / releaseSamples;
		}
		float currentFrequency = frequency + (frequencySlide * ((float)i / totalSamples)) + (deltaSlide * ((float)i / totalSamples) * ((float)i / totalSamples));
		currentFrequency = max(currentFrequency, 1.0f); // Prevent negative or zero frequency
		phase += (2.0f * 3.14159265f * currentFrequency) / sampleRate;
		waveData[i] = (short)(amplitude * envelope * (sinf(phase) >= 0 ? 1.0f : -1.0f) * volume);
	}
	wfx.Format.wFormatTag = WAVE_FORMAT_PCM;
	wfx.Format.nChannels = 1;
	wfx.Format.nSamplesPerSec = sampleRate;
	wfx.Format.wBitsPerSample = 16;
	wfx.Format.nBlockAlign = (wfx.Format.nChannels * wfx.Format.wBitsPerSample) / 8;
	wfx.Format.nAvgBytesPerSec = wfx.Format.nSamplesPerSec * wfx.Format.nBlockAlign;
	wfx.Format.cbSize = 0;
	buffer.AudioBytes = totalSamples * sizeof(short);
	buffer.pAudioData = (BYTE*)waveData;
	buffer.Flags = XAUDIO2_END_OF_STREAM;
	if (XAudioSource) {
		XAudioSource->Stop(0);
		XAudioSource->FlushSourceBuffers();
		XAudioSource->DestroyVoice();
	}
	HRESULT hr = XAudio->CreateSourceVoice(&XAudioSource, (WAVEFORMATEX*)&wfx);
	if (FAILED(hr)) {
		MessageBoxA(NULL, "Failed to create source voice!", "Time to debug", MB_OK);
		return;
	}
	hr = XAudioSource->SubmitSourceBuffer(&buffer);
	if (FAILED(hr)) {
		MessageBoxA(NULL, "Failed to submit source buffer!", "Time to debug", MB_OK);
		return;
	}
}

void AudioEngine::GenerateTriangleWave(float attackTime, float sustainTime, float releaseTime, float frequency, float frequencySlide, float deltaSlide, float volume) {
	const int sampleRate = 44100;
	const int amplitude = 32767;
	int attackSamples = (int)(attackTime * sampleRate);
	int sustainSamples = (int)(sustainTime * sampleRate);
	int releaseSamples = (int)(releaseTime * sampleRate);
	int totalSamples = attackSamples + sustainSamples + releaseSamples;
	short* waveData = new short[totalSamples];
	float phase = 0.0f;
	for (int i = 0; i < totalSamples; i++) {
		float envelope = 1.0f;
		if (i < attackSamples) {
			envelope = (float)i / attackSamples;
		}
		else if (i >= attackSamples + sustainSamples) {
			envelope = 1.0f - (float)(i - attackSamples - sustainSamples) / releaseSamples;
		}
		float currentFrequency = frequency + (frequencySlide * ((float)i / totalSamples)) + (deltaSlide * ((float)i / totalSamples) * ((float)i / totalSamples));
		currentFrequency = max(currentFrequency, 1.0f); // Prevent negative or zero frequency
		phase += (2.0f * 3.14159265f * currentFrequency) / sampleRate;
		waveData[i] = (short)(amplitude * envelope * (2.0f * fabs(2.0f * (phase / (2.0f * 3.14159265f) - floor(phase / (2.0f * 3.14159265f) + 0.5f))) - 1.0f) * volume);
	}
	wfx.Format.wFormatTag = WAVE_FORMAT_PCM;
	wfx.Format.nChannels = 1;
	wfx.Format.nSamplesPerSec = sampleRate;
	wfx.Format.wBitsPerSample = 16;
	wfx.Format.nBlockAlign = (wfx.Format.nChannels * wfx.Format.wBitsPerSample) / 8;
	wfx.Format.nAvgBytesPerSec = wfx.Format.nSamplesPerSec * wfx.Format.nBlockAlign;
	wfx.Format.cbSize = 0;
	buffer.AudioBytes = totalSamples * sizeof(short);
	buffer.pAudioData = (BYTE*)waveData;
	buffer.Flags = XAUDIO2_END_OF_STREAM;
	if (XAudioSource) {
		XAudioSource->Stop(0);
		XAudioSource->FlushSourceBuffers();
		XAudioSource->DestroyVoice();
	}
	HRESULT hr = XAudio->CreateSourceVoice(&XAudioSource, (WAVEFORMATEX*)&wfx);
	if (FAILED(hr)) {
		MessageBoxA(NULL, "Failed to create source voice!", "Time to debug", MB_OK);
		return;
	}
	hr = XAudioSource->SubmitSourceBuffer(&buffer);
	if (FAILED(hr)) {
		MessageBoxA(NULL, "Failed to submit source buffer!", "Time to debug", MB_OK);
		return;
	}
}

void AudioEngine::GenerateSawtoothWave(float attackTime, float sustainTime, float releaseTime, float frequency, float frequencySlide, float deltaSlide, float volume) {
	const int sampleRate = 44100;
	const int amplitude = 32767;
	int attackSamples = (int)(attackTime * sampleRate);
	int sustainSamples = (int)(sustainTime * sampleRate);
	int releaseSamples = (int)(releaseTime * sampleRate);
	int totalSamples = attackSamples + sustainSamples + releaseSamples;
	short* waveData = new short[totalSamples];
	float phase = 0.0f;
	for (int i = 0; i < totalSamples; i++) {
		float envelope = 1.0f;
		if (i < attackSamples) {
			envelope = (float)i / attackSamples;
		}
		else if (i >= attackSamples + sustainSamples) {
			envelope = 1.0f - (float)(i - attackSamples - sustainSamples) / releaseSamples;
		}
		float currentFrequency = frequency + (frequencySlide * ((float)i / totalSamples)) + (deltaSlide * ((float)i / totalSamples) * ((float)i / totalSamples));
		currentFrequency = max(currentFrequency, 1.0f); // Prevent negative or zero frequency
		phase += (2.0f * 3.14159265f * currentFrequency) / sampleRate;
		waveData[i] = (short)(amplitude * envelope * (2.0f * (phase / (2.0f * 3.14159265f) - floor(phase / (2.0f * 3.14159265f) + 0.5f))) * volume);
	}
	wfx.Format.wFormatTag = WAVE_FORMAT_PCM;
	wfx.Format.nChannels = 1;
	wfx.Format.nSamplesPerSec = sampleRate;
	wfx.Format.wBitsPerSample = 16;
	wfx.Format.nBlockAlign = (wfx.Format.nChannels * wfx.Format.wBitsPerSample) / 8;
	wfx.Format.nAvgBytesPerSec = wfx.Format.nSamplesPerSec * wfx.Format.nBlockAlign;
	wfx.Format.cbSize = 0;
	buffer.AudioBytes = totalSamples * sizeof(short);
	buffer.pAudioData = (BYTE*)waveData;
	buffer.Flags = XAUDIO2_END_OF_STREAM;
	if (XAudioSource) {
		XAudioSource->Stop(0);
		XAudioSource->FlushSourceBuffers();
		XAudioSource->DestroyVoice();
	}
	HRESULT hr = XAudio->CreateSourceVoice(&XAudioSource, (WAVEFORMATEX*)&wfx);
	if (FAILED(hr)) {
		MessageBoxA(NULL, "Failed to create source voice!", "Time to debug", MB_OK);
		return;
	}
	hr = XAudioSource->SubmitSourceBuffer(&buffer);
	if (FAILED(hr)) {
		MessageBoxA(NULL, "Failed to submit source buffer!", "Time to debug", MB_OK);
		return;
	}
}